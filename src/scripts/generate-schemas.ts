/**
 * generate Zod schemas from SQL metadata.
 *
 * Notes:
 * - Env vars are loaded via package.json scripts (`-r --env-file=.env`).
 * - Output is JSON-Schema friendly (dates/decimals/bigints/binaries as strings when needed).
 * - Files are formatted through Prettier and only written when content actually changes.
 */
import path from 'node:path'

import {
  groupBy,
  uniqBy,
  kebabCase,
  keys,
  size,
  get,
  map,
  includes,
  replace,
  filter,
  join,
  uniq,
} from 'lodash-es'

import db from '../lib/db.ts'
import sqlKit from '../sql/sql.ts'
import ensureLowerCase from '../utils/ensure-lower-case.ts'
import sqlTypeToZodString from '../utils/sql-type-to-zod-string.ts'
import toPascalCase from '../utils/to-pascal-case.ts'
import { writeFormattedFileToDir } from '../utils/write-file-to-dir.ts'

const SCHEMAS_DIR = path.resolve(process.cwd(), 'src/schemas')
const SCHEMAS_INDEX_FILE = 'index.ts'
const headerBanner = `/* Auto-generated by scripts/generate-schemas.ts.
 * Do NOT edit this file manually.
 */`

export type SchemaRow = {
  TABLE_SCHEMA: string
  TABLE_NAME: string
  COLUMN_NAME: string
  DATA_TYPE: string
  IS_NULLABLE: 'YES' | 'NO'
  CHARACTER_MAXIMUM_LENGTH: number | null
  IsIdentity: number
  IsPrimary: number
  IsUnique: number
  FK_RefTable: string | null
  FK_RefColumn: string | null
}
export type FKRow = { column: string; table: string; key: string }

async function generateSchemas() {
  const pool = await db.getPool()
  try {
    const { schemaInfo } = sqlKit.query
    const result = await pool.request().query<SchemaRow>(schemaInfo)
    const rows = result.recordset
    const byTable = groupBy(rows, (r) => `${r.TABLE_SCHEMA}.${r.TABLE_NAME}`)
    const models: { pascal: string; kebab: string }[] = []
    for (const key of keys(byTable)) {
      const items = byTable[key]
      if (!size(items)) continue

      const schema = get(items, ['0', 'TABLE_SCHEMA']) as string
      const table = get(items, ['0', 'TABLE_NAME']) as string
      const pascal = toPascalCase(table)
      const kebab = kebabCase(table)
      models.push({ pascal, kebab })
      const fieldLines = map(items, (col) => {
        const isNullable = col.IS_NULLABLE === 'YES'
        const maxLen = col.CHARACTER_MAXIMUM_LENGTH
        let zExpr = sqlTypeToZodString(col.DATA_TYPE, maxLen, isNullable)
        if (includes(ensureLowerCase(col.COLUMN_NAME), 'email')) {
          zExpr = replace(zExpr, 'string()', 'email()')
        }

        return `  ${JSON.stringify(col.COLUMN_NAME)}: ${zExpr},`
      })
      const primaryCols = map(
        filter(items, (r) => r.IsPrimary === 1),
        (r) => r.COLUMN_NAME,
      )
      const uniqueCols = map(
        filter(items, (r) => r.IsUnique === 1),
        (r) => r.COLUMN_NAME,
      )
      const fkRows = map<SchemaRow, FKRow>(
        filter(items, (r) => r.FK_RefTable && r.FK_RefColumn) as SchemaRow[],
        (r) => ({
          column: r.COLUMN_NAME,
          table: r.FK_RefTable!,
          key: r.FK_RefColumn!,
        }),
      )
      const fkUnique = uniqBy(fkRows, (f: FKRow) => `${f.column}:${f.table}:${f.key}`)
      const content = `${headerBanner}
import { z } from 'zod'

/** ${pascal} schema (table: ${schema}.${table}) */
export const ${pascal}Schema = z.object({
${join(uniq(fieldLines), '\n')}
}).meta({
    primary: ${JSON.stringify(primaryCols)},
    unique: ${JSON.stringify(uniqueCols)},
    foreignKey: ${JSON.stringify(fkUnique)},
    description: '${table}'
  })

export type ${pascal} = z.infer<typeof ${pascal}Schema>
`
      const outPath = await writeFormattedFileToDir(SCHEMAS_DIR, `${kebab}.schema.ts`, content)
      console.log('✔ wrote', outPath)
    }
    const indexHead = `import type { z } from 'zod'
    import { keys } from 'lodash-es'`
    const indexImports = join(
      map(
        models,
        ({ pascal, kebab }) =>
          `import { ${pascal}Schema } from './${kebab}.schema.ts'
          export type {${pascal}} from './${kebab}.schema.ts'`,
      ),
      '\n',
    )
    const registryObject = `export const SchemaRegistry = {
${join(
  map(models, ({ pascal }) => `  ${pascal}: ${pascal}Schema`),
  ',\n',
)}
} as const`
    const registryType = `
export type SchemaRegistry = typeof SchemaRegistry
export type SchemaName = keyof SchemaRegistry
export type SchemaOf<N extends SchemaName> = z.infer<SchemaRegistry[N]>
export const SchemaNames = keys(SchemaRegistry) as SchemaName[]
`
    const indexContent = `${headerBanner}
${indexHead}
${indexImports}

${registryObject}
${registryType}
`
    const indexOut = await writeFormattedFileToDir(SCHEMAS_DIR, SCHEMAS_INDEX_FILE, indexContent)
    console.log('✔ wrote', indexOut)
  } finally {
    await pool.close()
  }
}

generateSchemas().catch((err) => {
  console.error('generate-schemas failed:', err)
  process.exit(1)
})
